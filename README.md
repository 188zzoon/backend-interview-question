# Backend-Interview-Question

백엔드 개발자를 준비하면서 받았던 면접 질문, 학습했던 내용, 예상가능한 질문을 선별했습니다.

이 저작물은 CC BY-NC(저작자 표시-비영리)입니다.

기여를 통해서 더 좋은 컨텐츠가 될 수 있도록 해주세요.

이 컨텐츠의 목표는 가능하면 간단하게 면접질문에 대답을 할 수 있도록 하는 것입니다.

당연히 세부적인 지식에 대한 꼬리질문이 들어올 수 있으니, 깊이 있게 공부하는 것을 **권장**합니다.

신입 포지션에 대한 질문의 모음이기 때문에 경력직의 면접질문은 정리하지 않았습니다.

제가 Java를 주로 사용해서 타 언어에 대한 지식이 부족합니다. 보통 그 언어를 많이 사용해보았는지 정도의 문제가 출제됩니다. 기여가 가능하시다면 부탁드립니다.

백엔드 포지션은 면접 전 검증을 위해 과제 전형을 보는 경우도 많지만, 코딩테스트를 보는 경우가 훨씬 많습니다.

## 과제 전형

과제 전형은 애플리케이션 서버를 만들거나, 아니면 특정 프로그램을 작성하는 과제로 나눠질 수 있습니다.  
팁을 드리자면 출제 의도를 파악하려고 노력한 코딩을 하셔야합니다. 그리고, 면접에서 관련된 질문이 나올 수 있으니 사용해 본 기술이거나 처음 사용했더라도 학습을 해두셔야합니다. '왜 이 기술을 사용했는가?', '이 기술 말고 다른 선택지는 없는가?' 정도의 질문은 예상해 볼만한 질문이니 대비를 해둡시다. 과제가 통과되었다면 끝난 것이 아닙니다. 그 과제에서 더 개선할 부분은 무엇인지, 확장 포인트는 어디인지까지 고민해봅시다.

과제 전형 자체가 약간 새로운 시도에 가깝기 때문에 정답은 없습니다. 본인이 할 수 있는 최선을 다해서 해당 언어의 철학에 맞는 코드를 작성해봅시다. 가령 객체지향 프로그래밍 언어라면, '재사용성', '변경에 유연함'을 염두에 두고 개선 포인트를 잡아봅시다. 또, 해당 회사의 기술스택을 확인하고 이를 적용할만하다면 적극적으로 사용해봅시다. 최신 기술에 유연한 사고를 갖고 있다는 인상을 줄 수도 있습니다.

## 코딩테스트

코딩테스트는 여러 플랫폼이 있으며, 요즘은 프로그래머스를 많이 사용하고, 언어는 Python을 추천합니다.  
제가 추천하는 학습 방법은 2개월 정도를 잡고 코딩테스트 관련 서적을 한 권 끝내거나, 유형별 문제를 푸는 것이고, 여유가 있다면 1~2시간 풀어보고(난이도마다 상이) 풀었다면 시간 복잡도를 생각하고, 다른 풀이는 없는지 고민해봅시다. 대략 이 정도 수준의 공부를 하시고, 실력을 유지하기 위해 꾸준히 한 두 문제씩 풀어봅시다. 저는 코딩테스트가 약한편이어서 더 많은 팁을 드릴 수는 없을 것 같네요.

알고리즘 코딩테스트가 재밌다면 모르겠지만 저처럼 그리 즐겁지 않은신 분은 너무 자존심을 깎아가면서 까지 준비하지는 마시는걸 추천드립니다. 안풀리면 풀이를 보고 이해하시고, 이해가 가지 않는 문제는 현재의 나에겐 너무 어려운 문제일 뿐입니다. 나중에 다시 풀 때, 풀이 없이 풀려고 노력해보고, 같은 과정을 반복해봅시다.

실제 코딩테스트를 볼 때에는, 코드에 주석을 달아두는 편이 유용합니다. 내가 어떻게 풀려고 했는지 의도를 전달할 수 있기 때문입니다. 내가 작성한 코드를 문제와 함께 정리해둡시다. 합격한다면 어떤 질문이 나올지 생각해봅시다.

[![크리에이티브 커먼즈 라이선스](https://i.creativecommons.org/l/by-nc/2.0/kr/88x31.png)](http://creativecommons.org/licenses/by-nc/2.0/kr/)  
이 저작물은 [크리에이티브 커먼즈 저작자표시-비영리 2.0 대한민국 라이선스](http://creativecommons.org/licenses/by-nc/2.0/kr/)에 따라 이용할 수 있습니다.

## CS 관련 지식

### 네트워크

<details>
  <summary>웹 통신의 큰 흐름: https://www&#46;google&#46;com/ 을 접속할 때 일어나는 일</summary>
  </br>
  <p>면접 단골 문제입니다. 면접관 입장에서는 한 질문으로 많은 답변을 들을 수 있기 때문에 대부분의 면접자리에서 나왔던 문제입니다. OSI 7계층과도 연관지어 설명하라는 질문을 받은적도 있습니다.</p>
  <p>브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.</p>
  <p>크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다. 만약 없다면 루트 도메인부터 서브도메인 순으로 찾게됩니다.이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.</p>
  <p>패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.</br>
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.</p>
  <p>핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.</p>
  <p>웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다. 애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.</p>
</details>

<details>
  <summary>TCP와 UDP의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP는 연결 지향형 프로토콜이고 UDP는 데이터를 데이터그램단위로 전송하는 프로토콜입니다.</p>
  <p>TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린편입니다.</p>
  <p>TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.</p>
  <p>+) 하지만 UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. 그래서 HTTP 3.0은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다. 즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.</p>
</details>

<details>
  <summary>TCP 3, 4 way handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP가 가상회선을 만들고 제거하는 과정에 대해서 묻는 질문입니다. TCP를 공부하셨다면 이 정도는 알겠지 하고 묻는 문제고, 실제 면접자리에서는 보통 네트워크에 대해서 설명할 때, 직접 설명하는 편입니다.</p>
  <p>TCP 3way handshake는 가상회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다. SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다. 정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.</p>
  <p>왜 임의의 난수를 지정하느냐는 꼬리질문이 나올 수 있습니다. 기존 요청과 구분하기 위해서 정도로 알고있고, 그 이상은 생각해본적이 없네요.</p>
  </br>
  <p>TCP 4way handshake는 TCP연결을 해제하는 단계로, 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결이 해제됩니다. 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.</p>
</details>

<details>
  <summary>HTTP와 HTTPS의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있습니다. 따라서 보안이 취약해짐을 알 수 있습니다. 이를 보완하기 위해 나온 것이 HTTPS입니다. 중간에 암호화 계층을 거쳐서 패킷을 암호화합니다.</p>
</details>

<details>
  <summary>HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.</p>
  <p>제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.</p>
  <p>클라이언트는 TCP 3way handshake를 수행한 이후 Client Hello를 전송합니다. 서버는 인증서를 보냅니다.(다른 정보들도 전송하나 검색을 통해 알 수 있는 부분입니다. 대개 그 정도까지는 요구하지 않습니다.)</p>
  <p>클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다. 이 인증서는 인증기관의 개인키로 암호화되어있고, 공개키로 검증할 수 있습니다.(브라우저에 내장되어있음) 클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.</p>
  <p>서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다. 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.</p>
  <p>제3자 인증: 인증서, 인증기관/공개키 암호화: 인증서, 비밀키 공유/비밀키 암호화: 통신과정</p>
  <p>왜 공개키 암호화와 비밀키 암호화를 복합적으로 사용했는지도 질문을 받았습니다.</p>
</details>

<details>
  <summary>GET과 POST의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>대개의 경우 아래의 HTTP 메서드 질문을 더 많이합니다. 하지만 둘의 차이만을 물을 수도 있습니다.</p>
  <p>GET요청은 서버에 존재하는 정보를 요청합니다. 이 때 반환되는 정보는 정보 자체가 아니라 정보의 표현입니다.(뒤의 내용은 REST와 연관이 있고, 굳이 답변하지 않으셔도 됩니다.) 일반적으로 Request Body는 입력하지 않는 것이 일반적이며, 레거시 시스템의 경우 요청을 받아들이지 않을 수 있습니다. 캐싱을 수행하기 때문에 캐싱되지 않는 요청은 GET 요청이 맞지 않을 수 있습니다.</p>
  <p>POST요청은 서버에 정보를 생성하는 것을 요청합니다. 예전 HTTP 통신은 POST 요청으로 데이터 삭제, 수정도 form요청으로 같이 수행했습니다. POST 요청은 서버의 상태를 변경시키기 때문에 멱등성이 유지되지 않습니다. 보통 Request Body에 요청하는 데이터를 담아 전송합니다.</p>
</details>

<details>
  <summary>HTTP 메서드와 이것이 하는 역할에 대해서 설명해보세요.</summary>
  </br>
  <p>보통 REST API를 설계했다면 이해할 수 있을정도로 설명하면 되는 것 같습니다.</p>
  <p>OPTIONS, HEAD, TRACE의 존재에 대해서는 알아만 둡시다. 특히 TRACE는 몰라도 되는 것 같습니다. OPTIONS는 해당 uri에 대해 서버가 허용하는 메서드를 확인할 때 사용합니다. HEAD는 GET과 비슷하나 header만 가져옵니다.</p>
  <ul>
    <li>GET 요청은 서버에 존재하는 데이터를 요청하는 것입니다. CRUD로 따지면 R입니다.</li>
    <li>POST 요청은 서버에 데이터를 생성하는 것을 요청합니다. CRUD로 따지면 C입니다.</li>
    <li>PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성합니다. CRUD로 따지면 C,U입니다.</li>
    <li>DELETE 요청은 서버에 데이터를 제거할 것을 요청합니다. 존재하지 않아도 동일하게 동작합니다. CRUD로 따지면 D입니다.</li>
    <li>PATCH 요청은 서버에 존재하는 데이터를 일부 수정합니다. CRUD로 따지면 U입니다.</li>
  </ul>
  <p>더 나아가서 불필요한 메서드는 허용하지 않고 필요한 메서드만 허용하는 Whitelist 방식으로 관리합시다. 자세한 내용은 HTTP Method 취약점에 대해 검색합시다.</p>
</details>

<details>
  <summary>RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.(보충필요)</summary>
  </br>
  <p>REST는 굉장히 난해한 개념입니다. 하지만 REST가 무엇인지 대략의 감은 잡아둡시다. REST API를 설계했다면 충분히 물어볼만한 질문입니다.</p>
  <p>HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현합니다. 사람이 읽을 수 있는 API라는 것이 특징입니다. HTTP를 사용하기 때문에 HTTP의 특성을 그대로 반영합니다. 또한 별도의 인프라 구축이 필요없습니다.</p>
  <p>단점으로는 명확한 표준이 존재하지 않는다는 점, RESTful을 완전히 만족하는 API를 만들기는 매우 까다롭다는 점(그런 REST API로 괜찮은가 참고), REST API가 분산환경에 적합하지 않다는 점이 있습니다.(멱등성을 보장하기 힘들기 때문)</p>
  <p>HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게됩니다.(모든 관련된 동작을 URI를 통해 알려줍니다.) 즉, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점을 가져옵니다.</p>
</details>

<details>
<summary>CORS란 무엇이며 이것에 대해서 설명해보세요.</summary>
</br>
<p>CORS는 웹개발을 하다가 흔히 만날 수 있는 이슈입니다. 대개는 프론트엔드 개발시에 로컬에서 API 서버에 요청을 보낼 때 흔하게 발생합니다.</p>
<p>서로 다른 도메인간에 자원을 공유하는 것을 뜻합니다. 대부분의 브라우저에서는 이를 기본적으로 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.</p>
<p>preflight request는 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청입니다. OPTIONS 메서드로 요청하며 CORS를 허용하는지 확인합니다. CORS가 허용된 웹서버라면 사용 가능한 리소스를 헤더에 담아 응답합니다.</p>
</details>

<details>
<summary>OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요.</summary>
</br>
<p>OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.</p>
<p>실제로 우리가 대부분 사용하는 네트워크는 TCP/IP 4계층입니다. 통신에 실제로 사용되는 계층이고 1,2 계층이 1계층, 5, 6, 7계층이 4계층으로 운영됩니다.</p>
</details>

### 운영체제

### 데이터베이스

### 자료구조/알고리즘

### 암호학/보안(간단한 정도)

### 컴파일러

## 언어 관련

### Java

#### Spring/JPA

## 기타

### 디자인 패턴

### 테스트

### 인프라/클라우드

### 컨테이너

### DevOps

### 커뮤니케이션

### 최신기술에 관심이 있는지

### 웹서버의 동작과정

## 면접 꿀팁

<!--
<details>
<summary></summary>
</br>
<p></p>
</details>
-->
